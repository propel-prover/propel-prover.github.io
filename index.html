<!DOCTYPE html>
<html lang="en">
<head>
<title>Propel</title>
<meta charset="utf8">
<link rel="icon" type="image/png" href="/favicon.png">
<link rel="stylesheet" href="style.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@prg_grp">
<meta name="twitter:title" content="Propel - Type-check your CRDTs!">
<meta name="twitter:image" content="https://propel-prover.github.io/twitter_card.png">
<meta name="twitter:description" content="Propel - Type-check your CRDTs! Track commutativity, associativity, idempotency, and other algebraic properties in types. Propel is a programming language developed in the Programming Group at the University of St.Gallen. It allows developers to annonate functions with alegbraic properties such as commutativity, associativity, and idempotency.">
</head>
<body>

<nav>
<ul>
    <li><a href="#section-crdt">CRDTs</a></li>
    <li><a href="#section-properties">Properties</a></li>
    <li><a href="#section-getting-started">Getting Started</a></li>
    <li><a href="#section-scala-dsl">Scala DSL</a></li>
    <li><a href="#section-publications">Publications</a></li>
    <li><a href="https://github.com/propel-prover">GitHub</a></li>
    <li><a href="https://programming-group.com">Programming Group</a></li>
</ul>
</nav>

<header>
    <img src="logo.svg" width="350" height="100" alt="Propel">
</header>

<div class="summary">
<h1 id="tagtitle">Type-check your <a href="#section-crdt">CRDTs</a>!</h1>
<h2 id="tagline">
Track commutativity, associativity, idempotency, and <a href="#section-properties">other algebraic properties</a> in types
</h2>

<p>
Propel is a programming language developed in the <a href="https://programming-group.com">Programming Group</a> at the <a href="https://www.unisg.ch">University of St.&#x202F;Gal&shy;len</a>.
It allows developers to annotate functions with algebraic properties such as commutativity, associativity, and idempotency.
Propel’s type system uses a specialized automated inductive theorem prover to reason about these properties.
The language focuses on verifying the convergence properties of <a href="#section-crdt">CRDT</a> implementations.
Propel is available as a standalone language and as a <a href="#section-scala-dsl">Scala DSL</a>.
</p>
</div>

<div id="jumbo">
    <div id="interactiveCode">
        <h1>Try Propel</h1>
        <p>We compiled Propel to JavaScript using <a href="https://scala-js.org">Scala.js</a> for you to try the latest version locally in your browser.</p>
        <div id="autocomplete"><!--{{{-->
            <div id="syntax">
            <h3 id="syntax-definitions">Definitions</h3>
            <ul>
                <li class="selected">
                    <code>(def <em>&lt;var&gt;</em> [<em>&lt;type&gt;</em>] <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Introduces a definition that has is bound to <em>&lt;var&gt;</em> in the rest of the program.
                    Recursive definitions must designate their type.
                    Non-recursive definitions leave out the type declaration.
                    </div>
                </li>
                <li>
                    <code>(type <em>&lt;var&gt;</em> <em>&lt;type&gt;</em>)</code>
                    <div class="description">
                    Introduce a recursive or non-recursive type alias <em>&lt;var&gt;</em> for <em>&lt;type&gt;</em> in the rest of the program.
                    </div>
                </li>
            </ul>

            <h3 id="syntax-expressions">Expressions</h3>
            <ul>
                <li>
                    <code>(lambda [<em>&lt;[prop...]&gt;</em>] <em>&lt;arg...&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    A lambda expression with zero or more <em>&lt;properties&gt;</em>, one or more arguments of the form (<em>&lt;var&gt;</em> <em>&lt;type&gt;</em>), and a body <em>&lt;expr&gt;</em>.
                    The annotated properties are type-checked and will be part of the function’s type.
                    </div>
                </li>
                <li>
                    <code>(let <em>&lt;pattern&gt;</em> <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Introduces a definition for each free variable in a given pattern (that must be exhaustive) which matches the first expression in the second expression.
                    Non-trivial patterns are useful when a type has only one constructor, for example <code>Tuple</code>.
                    </div>
                </li>
                <li>
                    <code>(letrec <em>&lt;var&gt;</em> <em>&lt;type&gt;</em> <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Introduces a recursive definition for the first expression that has the designated type and is bound to <em>&lt;var&gt;</em> in the last expression.
                    </div>
                </li>
                <li>
                    <code>(lettype <em>&lt;var&gt;</em> <em>&lt;type&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Introduces a recursive or non-recursive type alias <em>&lt;var&gt;</em> for <em>&lt;type&gt;</em> in <em>&lt;expr&gt;</em>.
                    </div>
                </li>
                <li>
                    <code>(cases <em>&lt;expr&gt;</em> <em>&lt;[pattern expr]...&gt;</em>)</code>
                    <div class="description">
                    Pattern-matches on the result of the first expression.
                    Cases are surrounded by square brackets and each case has one pattern and one expression to be executed if the case matches.
                    </div>
                </li>
                <li>
                    <code>(if <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Performs a conditional check. The first expression must reduce to either <code>True</code> or <code>False</code>.
                    </div>
                </li>
                <li>
                    <code>(not <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Negates the booleans <code>True</code> or <code>False</code>.
                    </div>
                </li>
                <li>
                    <code>(and <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Computes the conjunction of two booleans.
                    </div>
                </li>
                <li>
                    <code>(or <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Computes the disjunction of two booleans.
                    </div>
                </li>
                <li>
                    <code>(implies <em>&lt;expr&gt;</em> <em>&lt;expr&gt;</em>)</code>
                    <div class="description">
                    Computes the implication between two booleans where the first expression is the antecedent and the second expression is the consequent.
                    </div>
                </li>
                <li>
                    <code>(<em>&lt;K&gt;</em> <em>&lt;expr...&gt;</em>)</code>
                    <div class="description">
                    Applies a constructor to its arguments.
                    </div>
                </li>
                <li>
                    <code>(<em>&lt;expr&gt;</em> <em>&lt;expr...&gt;</em>)</code>
                    <div class="description">
                    Applies an expression to its arguments.
                    </div>
                </li>
                <li>
                    <code>(<em>&lt;expr&gt;</em> <em>&lt;[expr...]&gt;</em>)</code>
                    <div class="description">
                    Applies an expression to its type arguments.
                    </div>
                </li>
            </ul>

            <h3 id="syntax-patterns">Patterns</h3>
            <ul>
                <li>
                    <code>(<em>&lt;K&gt;</em> <em>&lt;pattern...&gt;</em>)</code>
                    <div class="description">
                    A pattern that will only match expressions constructed with the constructor <em>&lt;K&gt;</em> and whose arguments match each subpattern.
                    </div>
                </li>
            </ul>

            <h3 id="syntax-types">Types</h3>
            <ul>
                <li>
                    <code>{<em>&lt;constructor...&gt;</em>}</code>
                    <div class="description">
                    Defines a tagged union defined by at least one constructor.
                    Additionally, if constructors take arguments, then the arguments’ types must follow after the constructor inside parenthesis.
                    </div>
                </li>
                <li>
                    <code>(rec <em>&lt;var&gt;</em> <em>&lt;type&gt;</em>)</code>
                    <div class="description">
                    Defines a recursive type and
                    <em>&lt;var&gt;</em> will be bound to the recursive type inside <em>&lt;type&gt;</em>.
                    </div>
                </li>
                <li>
                    <code>(forall <em>&lt;var&gt;</em> <em>&lt;type&gt;</em>)</code>
                    <div class="description">
                    Defines a polymorphic type and
                    <em>&lt;var&gt;</em> is bound in <em>&lt;type&gt;</em>.
                    </div>
                </li>
            </ul>

            <h3 id="syntax-properties">Properties</h3>
            <ul>
                <li>
                    <code>comm</code>
                    <div class="description">
                    Commutativity: <code>f x y = f y x</code>
                    </div>
                </li>
                <li>
                    <code>assoc</code>
                    <div class="description">
                    Associativity: <code>f (f x y) z = f x (f y z)</code>
                    </div>
                </li>
                <li>
                    <code>idem</code>
                    <div class="description">
                    Idempotency: <code>f x x = x</code>
                    </div>
                </li>
                <li>
                    <code>sel</code>
                    <div class="description">
                    Selectivity: <code>f x y = x</code> or <code>f x y = y</code>
                    </div>
                </li>
                <li>
                    <code>refl</code>
                    <div class="description">
                    Reflexivity: <code>f x x = True</code>
                    </div>
                </li>
                <li>
                    <code>irefl</code>
                    <div class="description">
                    Irreflexivity: <code>f x x = False</code>
                    </div>
                </li>
                <li>
                    <code>sym</code>
                    <div class="description">
                    Symmetry: If <code>f x y = True</code> then <code>f y x = True</code>
                    </div>
                </li>
                <li>
                    <code>antisym</code>
                    <div class="description">
                    Antisymmetry: If <code>f x y = True</code> and <code>f y x = True</code> then <code>x = y</code>
                    </div>
                </li>
                <li>
                    <code>asym</code>
                    <div class="description">
                    Assymetry: If <code>f x y = True</code> then <code>f y x = False</code>
                    </div>
                </li>
                <li>
                    <code>conn</code>
                    <div class="description">
                    Connectedness: <code>f x y = True</code> or <code>f y x = True</code>
                    </div>
                </li>
                <li>
                    <code>trans</code>
                    <div class="description">
                    Transitivity: If <code>f x y = True</code> and <code>f y z = True</code> then <code>f x z = True</code>
                    </div>
                </li>
            </ul>
            </div>
            <div id="selected-description">
            </div>
        <!--}}}--></div>
        <div id="controls">
            <input type="button" value="Check" id="checkCode">
            <select id="example">
                <option value="bv_eq" selected>Bitvector equality</option>
                <option value="nat_add3p">Peano Number addition</option>
                <option value="natlist_gcounter">GCounter</option>
                <option value="bv_lwwreg">Last-Writer-Wins Bitvector Register</option>
                <option value="gset">GSets encoded as functions</option>
                <option value="average">Peano number average</option>
                <option value="list-concat">List concatenation</option>
                <option value="nat-max">Peano number maximum</option>
                <option value="asym-eq">Peano number inequality</option>
                <option value="ancestor-transitivity">Cat ancestry</option>
                <option value="total-ord">Peano number ordering</option>
                <option value="divisibility">Peano number divisibility</option>
            </select>
            <input type="checkbox" id="printReduction">
            <label for="printReduction">Print reductions</label>
            <input type="checkbox" id="printDeduction">
            <label for="printDeduction">Print deductions</label>
            <input type="checkbox" id="checkOnInput">
            <label for="checkOnInput">Check on change</label>
        </div>
        <div id="codeAndConsole">
            <div id="codewrapper">
                <pre id="viewer"></pre>
                <textarea id="editor" spellcheck="false"></textarea>
            </div>
            <div id="consoleContainer">
                <pre id="console">Click <strong>Check</strong> to check your code</pre>
            </div>
        </div>
        <div id="status"><br></div>
    </div>
</div>

<main>
    <h1 id="section-crdt">Conflict-Free Replicated Datatypes (CRDTs)</h1>
    <img src="crdt.svg" width="400" height="400">
    <p>
    A state-based <em>Conflict-Free Rep&shy;li&shy;cat&shy;ed Da&shy;ta Type (CRDT)</em> is any datatype that defines a <code>merge</code> function that combines any two instances&mdash;any two replicas&mdash;into one without any conflict or manual conflict resolution.
    We expect the two following properties to hold:
    </p>
    <ol>
        <li>The order of merging any number of replicas should not change the result, and</li>
        <li>merging a replica with itself must not introduce any change to that replica, i.e. the replica remains constant.</li>
    </ol>
    <p>
    When applied to two replicas the first property entails that <code>merge</code> must be <em>commutative</em>.
    When applied to three or more replicas the first property entails that <code>merge</code> must be <em>associative</em>.
    And the second property entails that <code>merge</code> must be <em>idempotent</em>.
    </p>

    <h2>Example: GCounter</h2>
    <img src="gcounter.svg" width="600" height="480">
    <p>A <em>conflict-free rep&shy;li&shy;cat&shy;ed grow&shy;ing count&shy;er (GCounter)</em> between three peers is implemented as a map between a peer’s identifier and a number.
    The counter not only tracks the number of increments but tracks the origin of each increment.
    For example in the following figure, at the beginning&mdash;on the first line&mdash;the purple peer incremented the counter 9 times, received 0 increments from the yellow peer and 3 increments from the green peer.
    On the other hand the yellow peer received 7 increments from the purple peer, incremented its counter 2 times, and received 4 increments from the green peer.
    After syncing the purple and the yellow peer&mdash;on the second line&mdash;both agree on the number of increments.
    They do so by taking the pair-wise maximum number of increments.
    Finally after all peers sync&mdash;on the last line&mdash;they all agree on the number of increments and they are all able to deduce that there were 9&thinsp;+&thinsp;2&thinsp;+&thinsp;5&thinsp;=&thinsp;16 increments in total among them.
    </p>
    <p>The following two code snippets show how a GCounter can be implemented using Propel’s language which you can use in the editor above, and using Propel’s Scala DSL.</p>
    <div class="code-example">
        <div class="code-example-50">
            <h3>Propel Language</h3>
<!--{{{--><pre class="preview"><code class="line indent-0"><span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">type</span> nat <span style="color:#888888;font-weight:normal">{</span><span style="color:#8700af;font-weight:normal">Zero</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Succ</span> nat<span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">}</span><span style="color:#888888;font-weight:normal">)</span>      <span style="color:#878787;font-weight:normal">; natural numbers</span></code>
<code class="line indent-0"><span style="color:#888888;font-weight: normal;">(</span><span style="color:#d75f00;font-weight:bold">type</span> list <span style="color:#888888;font-weight:normal">{</span><span style="color:#8700af;font-weight:normal">Nil</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Cons</span> nat list<span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">}</span><span style="color:#888888;font-weight:normal">)</span> <span style="color:#878787;font-weight:normal">; lists</span></code>
<code class="line indent-0"></code>
<code class="line indent-0"><span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">def</span> max <span style="color:#888888;font-weight:normal">(</span><span style="color:#0087af;font-weight:normal">fun</span> nat nat nat<span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-2">  <span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">lambda</span> <span style="color:#888888;font-weight:normal">[</span><span style="color:#d70087;font-weight:bold">comm</span> <span style="color:#d70087;font-weight:bold">assoc</span> <span style="color:#d70087;font-weight:bold">idem</span><span style="color:#888888;font-weight:normal">]</span> <span style="color:#888888;font-weight:normal">(</span>x nat<span style="color:#888888;font-weight:normal">)</span> <span style="color:#888888;font-weight:normal">(</span>y nat<span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-4">    <span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">cases</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> x y<span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-6">      <span style="color:#888888;font-weight:normal">[</span><span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> <span style="color:#8700af;font-weight:normal">Zero</span> y<span style="color:#888888;font-weight:normal">)</span> y<span style="color:#888888;font-weight:normal">]</span></code>
<code class="line indent-6">      <span style="color:#888888;font-weight:normal">[</span><span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> x <span style="color:#8700af;font-weight:normal">Zero</span><span style="color:#888888;font-weight:normal">)</span> x<span style="color:#888888;font-weight:normal">]</span></code>
<code class="line indent-6">      <span style="color:#888888;font-weight:normal">[</span><span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Succ</span> a<span style="color:#888888;font-weight:normal">)</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Succ</span> b<span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Succ</span> <span style="color:#888888;font-weight:normal">(</span>max a b<span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">]</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-0"></code>
<code class="line indent-0"><span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">def</span> mergeGCounter <span style="color:#888888;font-weight:normal">(</span><span style="color:#0087af;font-weight:normal">fun</span> list list list<span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-2">  <span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">lambda</span> <span style="color:#888888;font-weight:normal">[</span><span style="color:#d70087;font-weight:bold">comm</span> <span style="color:#d70087;font-weight:bold">assoc</span> <span style="color:#d70087;font-weight:bold">idem</span><span style="color:#888888;font-weight:normal">]</span> <span style="color:#888888;font-weight:normal">(</span>x list<span style="color:#888888;font-weight:normal">)</span> <span style="color:#888888;font-weight:normal">(</span>y list<span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-4">    <span style="color:#888888;font-weight:normal">(</span><span style="color:#d75f00;font-weight:bold">cases</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> x y<span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-6">      <span style="color:#888888;font-weight:normal">[</span><span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> <span style="color:#8700af;font-weight:normal">Nil</span> _<span style="color:#888888;font-weight:normal">)</span> <span style="color:#8700af;font-weight:normal">Nil</span><span style="color:#888888;font-weight:normal">]</span></code>
<code class="line indent-6">      <span style="color:#888888;font-weight:normal">[</span><span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> _ <span style="color:#8700af;font-weight:normal">Nil</span><span style="color:#888888;font-weight:normal">)</span> <span style="color:#8700af;font-weight:normal">Nil</span><span style="color:#888888;font-weight:normal">]</span></code>
<code class="line indent-6">      <span style="color:#888888;font-weight:normal">[</span><span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Tuple</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Cons</span> a xs<span style="color:#888888;font-weight:normal">)</span> <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Cons</span> b ys<span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span></code>
<code class="line indent-7">       <span style="color:#888888;font-weight:normal">(</span><span style="color:#8700af;font-weight:normal">Cons</span> <span style="color:#888888;font-weight:normal">(</span>max a b<span style="color:#888888;font-weight:normal">)</span> <span style="color:#888888;font-weight:normal">(</span>mergeGCounter xs ys<span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">]</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal">)</span><span style="color:#888888;font-weight:normal"></span></code></pre><!--}}}-->
    </div>

        <div class="code-example-50">
            <h3>Propel in Scala</h3>
<!--{{{--><pre class="preview"><code class="line indent-0"><span style="color:#d75f00; font-weight:bold">enum</span> Nat:</code>
<code class="line indent-2">  <span style="color:#d75f00; font-weight:bold">case</span> <span style="color:#8700af">Zero</span></code>
<code class="line indent-2">  <span style="color:#d75f00; font-weight:bold">case</span> <span style="color:#8700af">Succ</span>(pred: Nat)</code>
<code class="line indent-0"></code>
<code class="line indent-0"><span style="color:#d75f00; font-weight:bold">def</span> max =</code>
<code class="line indent-2">  <span style="color:#d75f00; font-weight:bold">prop.rec</span>[<span style="color:#0087af">(<span style="color:#d70087;font-weight:bold">Comm</span> &amp; <span style="color:#d70087;font-weight:bold">Assoc</span> &amp; <span style="color:#d70087;font-weight:bold">Idem</span>) := (Nat, Nat) =>: Nat</span>]: max =></code>
<code class="line indent-4">    <span style="color:#d75f00; font-weight:bold">case</span> (Nat.<span style="color:#8700af">Zero</span>, y) => y</code>
<code class="line indent-4">    <span style="color:#d75f00; font-weight:bold">case</span> (x, Nat.<span style="color:#8700af">Zero</span>) => x</code>
<code class="line indent-4">    <span style="color:#d75f00; font-weight:bold">case</span> (Nat.<span style="color:#8700af">Succ</span>(n), Nat.<span style="color:#8700af">Succ</span>(m)) => Nat.<span style="color:#8700af">Succ</span>(max(n, m))</code>
<code class="line indent-0"></code>
<code class="line indent-0"><span style="color:#d75f00; font-weight:bold">def</span> zipWith[<span style="color:#0087af">P >: (</span><span style="color:#d70087;font-weight:bold">Comm</span><span style="color:#0087af"> &amp; </span><span style="color:#d70087;font-weight:bold">Assoc</span><span style="color:#0087af"> &amp; </span><span style="color:#d70087;font-weight:bold">Idem</span><span style="color:#0087af">)</span>, <span style="color:#0087af">T</span>] =</code>
<code class="line indent-2">  <span style="color:#d75f00; font-weight:bold">prop.rec</span>[<span style="color:#0087af">(P := (T, T) =>: T) =></span></code>
<code class="line indent-11">           <span style="color:#0087af">(P := (List[T], List[T]) =>: List[T])</span>]:</code>
<code class="line indent-4">    zipWith => f =></code>
<code class="line indent-6">      <span style="color:#d75f00; font-weight:bold">case</span> (<span style="color:#8700af">Nil</span>, y) => y</code>
<code class="line indent-6">      <span style="color:#d75f00; font-weight:bold">case</span> (x, <span style="color:#8700af">Nil</span>) => x</code>
<code class="line indent-6">      <span style="color:#d75f00; font-weight:bold">case</span> (x <span style="color:#8700af">::</span> xs, y <span style="color:#8700af">::</span> ys) => f(x, y) <span style="color:#8700af">::</span> zipWith(f)(xs, ys)</code>
<code class="line indent-0"></code>
<code class="line indent-0"><span style="color:#d75f00; font-weight:bold">def</span> mergeGCounter =</code>
<code class="line indent-2">  <span style="color:#d75f00; font-weight:bold">prop</span>[<span style="color:#0087af">(<span style="color:#d70087;font-weight:bold">Comm</span> &amp; <span style="color:#d70087;font-weight:bold">Assoc</span> &amp; <span style="color:#d70087;font-weight:bold">Idem</span>) :=</span></code>
<code class="line indent-7">       <span style="color:#0087af">(List[Nat], List[Nat]) =>: List[Nat]</span>]:</code>
<code class="line indent-4">    zipWith(max)</code></pre><!--}}}-->
        </div>
    </div>

    <h2>How do we guarantee that implementations of <code>merge</code> satisfy these properties?</h2>
    <p>
    The state of the art is to verify models of these CRDTs manually or automatically by instantiating some framework.
    Other works have developed code synthesizers that generate a <code>merge</code> function with the required properties given the desired semantics.
    Both approaches limit developers.
    Our solution is to develop a type-system that tracks these properties and a compiler that can prove these properties at compile-time.
    </p>

    <h1 id="section-properties">Properties We Support</h1>
    <h2>Binary Functions</h2>
    <div class="prop_box">
    <div class="prop_card">
        <h3>Commutativity</h3>
        <img src="/diagrams/comm.svg" width="210" height="210">
        <p>A commutative function is one whose arguments can be given in any order without changing the result</p>
        <p>E.g. Average of two numbers</p>
        <button data-example="average">Load in Editor</button>
    </div>
    <div class="prop_card">
        <h3>Idempotency</h3>
        <img src="/diagrams/idem.svg" width="210" height="210">
        <p>If an idempotent function is called with the same argument it must return it</p>
        <p>E.g. Set union</p>
        <button data-example="gset">Load in Editor</button>
    </div>
    <div class="prop_card">
        <h3>Associativity</h3>
        <img src="/diagrams/assoc.svg" width="210" height="210">
        <p>An associative function is one that can be folded in any direction on arguments without changing the result</p>
        <p>E.g. List concatenation</p>
        <button data-example="matrix-mult">Load in Editor</button>
    </div>
    <div class="prop_card">
        <h3>Selectivity</h3>
        <img src="/diagrams/sel.svg" width="210" height="210">
        <p>A selective function must always return one of its arguments</p>
        <p>E.g. Maximum of two numbers</p>
        <button data-example="nat-max">Load in Editor</button>
    </div>
    </div>


    <h2>Binary Relations</h2>
    <div class="prop_box">
        <div class="prop_card">
            <h3>Reflexivity</h3>
            <img src="/diagrams/refl.svg" width="210" height="210">
            <p>A reflexive relation is one where every element is related to itself</p>
            <p>E.g. Equality</p>
            <button data-example="bv_eq">Load in Editor</button>
        </div>
        <div class="prop_card">
            <h3>Symmetric</h3>
            <img src="/diagrams/sym.svg" width="210" height="210">
            <p>A symmetric relation is one where an element is related to another if and only if the other is related to it</p>
            <p>E.g. Inequality</p>
            <button data-example="asym-eq">Load in Editor</button>
        </div>
        <div class="prop_card">
            <h3>Transitivity</h3>
            <img src="/diagrams/trans.svg" width="210" height="210">
            <p>In a transitive relation if an element <em>a</em> is related to <em>b</em> and <em>b</em> is related to <em>c</em> then <em>a</em> must be related to <em>c</em></p>
            <p>E.g. Ancestry</p>
            <button data-example="ancestor-transitivity">Load in Editor</button>
        </div>
        <div class="prop_card">
            <h3>Connectivity</h3>
            <img src="/diagrams/conn.svg" width="210" height="210">
            <p>A connected relation is one where between any two distinct elements some relation exists</p>
            <p>E.g. Total order</p>
            <button data-example="total-ord">Load in Editor</button>
        </div>
        <div class="prop_card">
            <h3>Antisymmetry</h3>
            <img src="/diagrams/antisym.svg" width="210" height="210">
            <p>An antisymmetric relation is one where between any two distinct elements at most one relation exists</p>
            <p>E.g. Divisibility</p>
            <button data-example="divisibility">Load in Editor</button>
        </div>
    </div>

    <h1 id="section-getting-started">Getting Started</h1>

<h2>Building and Loading the Propel Docker image</h2>

<p>
We provide you with <code>propel.tar.xz</code> on <a href="https://doi.org/10.5281/zenodo.7817421">Zenodo (doi: 10.5281/zenodo.7817421)</a>, which is a pre-built container image that contains all necessary programs.
To load, run the following command:
</p>
<pre><code>$ <span class="select">docker load &lt; propel.tar.xz</span></code></pre>

<p>
Further, we also provide the option to build the contain anew. To build, run the
following command which takes between 10 and 20 minutes:
</p>
<pre><code>$ <span class="select">docker build -t propel .</span></code></pre>

<p>
Rebuilding the image may not work on Apple M1 machines because of incomplete emulation of system calls (specifically the <code>inotify</code> kernel subsystem).
Hence, we recommend rebuilding the image on a platform fully supported by Docker, like x86-64 systems.
</p>

<h2>Compiling Propel</h2>
<p>
The provided container already contains a binary executable of Propel.
</p>

<p>
To compile Propel to Java bytecode yourself, run the following command:
</p>
<pre><code>$ <span class="select">docker run -it --rm propel bash -c 'cd /propel; sbt clean compile'</span></code></pre>

<p>
To compile Propel to a native binary yourself, run the following command:
</p>
<pre><code>$ <span class="select">docker run -it --rm propel bash -c 'cd /propel; sbt clean nativeLink'</span></code></pre>

<p>
Compiling Propel, to bytecode or to a native executable, may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.
</p>

<p>
The resulting binary is at <code>/propel/<span class="break">&#x200b;</span>.native/<span class="break">&#x200b;</span>target/<span class="break">&#x200b;</span>scala-3.2.2/<span class="break">&#x200b;</span>propel</code>.
The <code>propel</code> executable in the <code>$PATH</code> is already symlinked to that binary file.
Hence, by default, you can just run <code>propel</code>.
</p>


    <h1 id="section-scala-dsl">Scala DSL</h1>

<h2>From the Propel Docker image</h2>
<p>
Propel is also provided as a DSL in Scala.
To experiment with the DSL, we invite you take a look into the following files in the <a href="https://doi.org/10.5281/zenodo.7817421">Propel Docker image</a>:
<code>/propel/<span class="break">&#x200b;</span>src/<span class="break">&#x200b;</span>test/<span class="break">&#x200b;</span>scala/<span class="break">&#x200b;</span>propel/<span class="break">&#x200b;</span>ScalaExamplesNat.scala</code>,
<code>/propel/<span class="break">&#x200b;</span>src/<span class="break">&#x200b;</span>test/<span class="break">&#x200b;</span>scala/<span class="break">&#x200b;</span>propel/<span class="break">&#x200b;</span>ScalaExamplesNum.scala</code> and
<code>/propel/<span class="break">&#x200b;</span>src/<span class="break">&#x200b;</span>test/<span class="break">&#x200b;</span>scala/<span class="break">&#x200b;</span>propel/<span class="break">&#x200b;</span>ScalaExamplesList.scala</code> inside the container.
</p>

<p>
As an example, you can execute the following commands to run a shell, explore the files and recompile the project:
</p>
<pre><code>$ <span class="select">docker run -it --rm propel bash</span>                               # open a shell</code>
<code>$ <span class="select">nano /propel/src/test/scala/propel/ScalaExamplesList.scala</span>    # open the file</code>

<code># edit and save the file</code>
<code>$ <span class="select">cd /propel &amp;&amp; sbt Test/compile</span>                                # recompile</code></pre>

<p>
Compiling the examples may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.
</p>

<p>
You may define your own function using the following syntax:
</p>
<pre><code><span class="select">def myFunction = prop[(FunctionProperties) := (T1, T1) =>: T2] { (x, y) => body }</span></code>
<code>// or</code>
<code><span class="select">def myRecursiveFunction = prop.rec[(FunctionProperties) := (T1, T1) =>: T2] { myRecursiveFunction => (x, y) => body }</span></code></pre>
<p>
Here, <code>myFunction</code> is the name of the function, <code>FunctionProperties</code> is a list of function properties the function has (separated by <code>&amp;</code>), <code>T1</code> is the type of the arguments of the binary function, <code>T2</code> is the return type of the function, <code>x</code> and <code>y</code> are the names of the function arguments, and <code>body</code> is the function body.
</p>

<p>
The function properties are chosen from the following list: <code>Comm</code>, <code>Assoc</code>, <code>Idem</code>, <code>Sel</code>, <code>Refl</code>, <code>Antisym</code>, <code>Trans</code>, <code>Conn</code>, and <code>Sym</code>.
</p>

<p>
If Propel is able to prove the properties that the function is annotated with, then compilation succeeds.
If the properties cannot be proven, then a compilation error indicates which property could not be proven.
</p>

<p>
For example, you can add the following GCounter CRDT example to one of the files in <code>/propel/<span class="break">&#x200b;</span>src/<span class="break">&#x200b;</span>test/<span class="break">&#x200b;</span>scala/<span class="break">&#x200b;</span>propel</code>:
</p>
<pre><code><span class="select">def mergeGCounter = prop[(Comm &amp; Assoc &amp; Idem) := (List[Num], List[Num]) =>: List[Num]] { zipWith(maxNum) }</span></code></pre>


    <h1 id="section-publications">Publications</h1>
    <ol class="publications">
        <li>George Zakhour, Pascal Weisenburger, and Guido Salvaneschi. 2023. Type-Checking CRDT Convergence.
            <i>Proceedings of the ACM on Programming Languages</i>&nbsp;7, PLDI, Article&nbsp;162, June 17&ndash;21, 2023, Orlando, Florida, United States. <a href="https://doi.org/10.1145/3591276">https://<span class="break">&#x200b;</span>doi.org/<span class="break">&#x200b;</span>10.1145/3591276</a> [<a href="https://programming-group.com/assets/pdf/papers/2023_Type-Checking-CRDT-Convergence.pdf">author version</a>]</li>
    </ol>
</main>

<footer>
Propel is a research language developed at the <a href="https://programming-group.com">Programming Group</a>
&copy; 2023
</footer>

<script type="text/propel" id="bv_eq">
; type definitions
(type bitvec {(B0 bitvec) (B1 bitvec) BZ})
(type bool {True False})

; definition of equality over bitvectors
(def bv_eq (fun bitvec bitvec bool)
  ; it must be reflexive, transitive, and antisymmetric
  (lambda [refl trans antisym] (x bitvec) (y bitvec)
    (cases (Tuple x y)
      [(Tuple BZ BZ) True]
      [(Tuple (B0 x) (B0 y)) (bv_eq x y)]
      [(Tuple (B1 x) (B1 y)) (bv_eq x y)]
      [_ False])))
</script>

<script type="text/propel" id="nat_add3p">
; type definitions
(type nat {(S nat) Z})

; definition of addition over the natural numbers
(def nat_add3p (fun nat nat nat)
  ; it must be commutative and associative
  (lambda [comm assoc] (x nat) (y nat)
    (cases (Tuple x y)
      [(Tuple Z y) y]
      [(Tuple x Z) x]
      [(Tuple (S x) (S y)) (S (S (nat_add3p x y)))])))
</script>

<script type="text/propel" id="natlist_gcounter">
; type definitions
(type nat {(S nat) Z})
(type natlist {(Cons nat natlist) Nil})

; definition of maximum over the natural numbers
(def nat_max (fun nat nat nat)
  ; it must be idempotent, commutative, and associative
  (lambda [idem comm assoc] (x nat) (y nat)
    (cases (Tuple x y)
      [(Tuple Z y) y]
      [(Tuple x Z) x]
      [(Tuple (S x) (S y)) (S (nat_max x y))])))

; definition of the merge function of a GCounter
(def gcounter_merge (fun natlist natlist natlist)
  ; it must be idempotent, commutative, and associative
  (lambda [idem comm assoc] (x natlist) (y natlist)
    (cases (Tuple x y)
      [(Tuple Nil y) y]
      [(Tuple x Nil) x]
      [(Tuple (Cons x xs) (Cons y ys))
       (Cons (nat_max x y) (gcounter_merge xs ys))])))
</script>

<script type="text/propel" id="bv_lwwreg">
; bitvectors are either empty (BZ), or a bitvector with a 0 at the
; end (B0) or a bitvector with a 1 at the end (B1)
(type bitvec {(B0 bitvec) (B1 bitvec) BZ})

; booleans
(type bool {True False})

; a last-writer-wins register is a pair of data (here a bitvector)
; and a timestamp (also a bitvector)
(type reg {(LWWReg bitvec bitvec)})

; equality of bitvectors
; PS: BZ != (B0 BZ)
(def bv_eq (fun bitvec bitvec bool)
  ; transitivity is required for the proof of associativity of
  ; `lwwreg_merge` but we can omit it because the compiler will
  ; conjecture it and prove it
  (lambda [refl sym antisym] (x bitvec) (y bitvec)
    (cases (Tuple x y)
      [(Tuple BZ BZ) True]
      [(Tuple (B0 x) (B0 y)) (bv_eq x y)]
      [(Tuple (B1 x) (B1 y)) (bv_eq x y)]
      [_ False])))

; the maximum of bitvectors
(def bv_max (fun bitvec bitvec bitvec)
  (lambda [comm assoc idem] (x bitvec) (y bitvec)
    (cases (Tuple x y)
      [(Tuple BZ y) y]
      [(Tuple x BZ) x]
      [(Tuple (B0 x) (B0 y)) (B0 (bv_max x y))]
      [(Tuple (B1 x) (B1 y)) (B1 (bv_max x y))]
      [(Tuple (B0 x) (B1 y))
        (if (bv_eq (bv_max x y) y) ; i.e. y >= x
            (B1 y)
            (B0 x))]
      [(Tuple (B1 x) (B0 y))
        (if (bv_eq (bv_max x y) x) ; i.e. x >= y
            (B1 x)
            (B0 y))])))

; compute the merge of two last-writer-wins registers
(def lwwreg_merge (fun reg reg reg)
  (lambda [comm assoc idem] (x reg) (y reg)
    ; we destruct each register to get the data and timestamp
    (let (Tuple (LWWReg xd xt) (LWWReg yd yt)) (Tuple x y)
      (if (bv_eq xt yt)
        ; even when the timestamps are equal the data must still be merged
        (LWWReg (bv_max xd yd) xt)
        (if (bv_eq (bv_max xt yt) xt) ; i.e. xt >= yt
            x
            y)))))
</script>


<script type="text/propel" id="gset">
(type bool {True False})

; we encode a set as a function returning a boolean `fun t bool`
; thus the only operation possible on such a set is
; membership testing by calling the set with the member

; the GSet merge is polymorphic over the contents of the set
(def gset_merge (forall t (fun (fun t bool)
                               (fun t bool)
                               t bool))
  (lambda t ; t is a type variable
    (lambda [comm assoc idem] (x (fun t bool)) (y (fun t bool))
      (lambda (e t) (or (x e) (y e))))))
</script>


<script type="text/propel" id="average">
(type nat {Z (S nat)})

(def add (fun nat nat nat)
  (lambda [comm] (a nat) (b nat)
    (cases a
      [Z b]
      [(S a) (S (add a b))])))

(def half (fun nat nat)
  (lambda (a nat)
    (cases a
      [Z Z]
      [(S Z) Z]
      [(S (S a)) (S (half a))])))

(def avg (fun nat nat nat)
  (lambda [comm] (a nat) (b nat)
    (half (add a b))))
</script>


<script type="text/propel" id="list-concat">
(type nat {(S nat) Z})
(type natlist {(Cons nat natlist) Nil})

(def concat (fun natlist natlist natlist)
  (lambda [assoc] (a natlist) (b natlist)
    (cases a
      [Nil b]
      [(Cons a as) (Cons a (concat as b))])))
</script>


<script type="text/propel" id="nat-max">
(type nat {(S nat) Z})

(def max (fun nat nat nat)
  (lambda [sel] (a nat) (b nat) (cases (Tuple a b)
    [(Tuple Z b) b]
    [(Tuple a Z) a]
    [(Tuple (S a) (S b)) (S (max a b))])))
</script>

<script type="text/propel" id="asym-eq">
(type nat {(S nat) Z})
(type bool {True False})

(def not-eq (fun nat nat bool)
  (lambda [sym] (a nat) (b nat) (cases (Tuple a b)
    [(Tuple Z Z) False]
    [(Tuple (S _) Z) True]
    [(Tuple Z (S _)) True]
    [(Tuple (S a) (S b)) (not-eq a b)])))
</script>

<script type="text/propel" id="ancestor-transitivity">
(type bool {True False})

(type Cat {Nutmeg Jake           Dovewing Socks
;            |     |                 |      |
;       ---------------          ----------------
;       |             |          |              |
     Princess      Firestar  Sandstorm      Cloudtail
;                     |          |
;                     ------------
;                          |
                       Jayfeather                      })


(def cat-eq (fun Cat Cat bool)
  (lambda (a Cat) (b Cat) (cases (Tuple a b)
    [(Tuple Jayfeather Jayfeather) True]
    [(Tuple Princess Princess) True]
    [(Tuple Firestar Firestar) True]
    [(Tuple Sandstorm Sandstorm) True]
    [(Tuple Cloudtail Cloudtail) True]
    [(Tuple Nutmeg Nutmeg) True]
    [(Tuple Jake Jake) True]
    [(Tuple Dovewing Dovewing) True]
    [(Tuple Socks Socks) True]
    [_ False])))


(def cat-parent (fun Cat {(Tuple Cat Cat) Unknown})
  (lambda (a Cat) (cases a
    [Jayfeather (Tuple Firestar Sandstorm)]
    [Princess (Tuple Nutmeg Jake)]
    [Firestar (Tuple Nutmeg Jake)]
    [Sandstorm (Tuple Dovewing Socks)]
    [Cloudtail (Tuple Dovewing Socks)]
    [_ Unknown])))


(def cat-is-ancestor (fun Cat Cat bool)
  (lambda [trans] (ancestor Cat) (cat Cat)
    (if (cat-eq ancestor cat)
        True
        (cases (cat-parent cat)
          [Unknown False]
          [(Tuple mother father)
           (or (cat-is-ancestor ancestor mother)
               (cat-is-ancestor ancestor father))]))))
</script>


<script type="text/propel" id="total-ord">
(type nat {(S nat) Z})
(type bool {True False})

(def leq (fun nat nat bool)
  (lambda [conn] (a nat) (b nat) (cases (Tuple a b)
    [(Tuple Z _) True]
    [(Tuple _ Z) False]
    [(Tuple (S a) (S b)) (leq a b)])))
</script>


<script type="text/propel" id="divisibility">
(type nat {(S nat) Z})
(type bool {True False})

(def eq (fun nat nat bool)
  (lambda (a nat) (b nat) (cases (Tuple a b)
    [(Tuple Z Z) True]
    [(Tuple (S _) Z) False]
    [(Tuple Z (S _)) False]
    [(Tuple (S x) (S y)) (eq x y)])))

(def less (fun nat nat bool)
  (lambda (a nat) (b nat) (cases (Tuple a b)
    [(Tuple Z Z) False]
    [(Tuple Z (S _)) True]
    [(Tuple (S _) Z) False]
    [(Tuple (S x) (S y)) (less x y)])))

(def sub (fun nat nat nat)
  (lambda (a nat) (b nat) (cases (Tuple a b)
    [(Tuple a Z) a]
    [(Tuple Z a) Z]
    [(Tuple (S x) (S y)) (sub x y)])))

(def divisible-by (fun nat nat bool)
  (lambda [antisym] (a nat) (b nat)
    (and (not (eq b Z))
         (if (less a b)
             (eq a Z)
             (divisible-by (sub a b) b)))))
</script>

<script src="editor.js"></script>
</body>
</html>
