<!DOCTYPE html>
<html>
<head>
<title>Propel</title>
<meta charset="utf8">
<link rel="stylesheet" href="style.css">
</head>
<body>

<header>
    <div id="logo">
        Propel
    </div>

    <ul id="nav">
        <li><a href="https://programming-group.com">Programming Group</a></li>
        <li><a href="https://github.com/propel-prover">GitHub</a></li>
    </ul>
</header>

<div id="jumbo">
    <div id="interactiveCode">
        <h1>Try Propel</h1>
        <h2>Check the commutativity, associativity, idempotency, and other algebraic properties of
        your binary functions and relations in the browser</h2>
        <div id="autocomplete"><!--{{{-->
            <div class="hint">Use the Up/Down arrow to cycle through the options. Click Enter to introduce the syntactic form. Click ESC to close popup</div>
            <div id="syntax">
            <h3>Expressions</h3>
            <ul>
                <li class="selected">
                    <code>(lambda [<em>prop...</em>] <em>arg...</em> <em>expr</em>)</code>
                    <div class="description">
                    A lambda expression with zero or more <em>properties</em>, one or more arguments of the form <code>(var type)</code>, and an expression.
                    The annotated properties are type checked and will be part of the function's type.
                    </div>
                </li>
                <li>
                    <code>(letrec <em>var</em> <em>type</em> <em>expr</em>)</code>
                    <div class="description">
                    Introduces a recursive definition bound to <em>var</em> that has the designed type and an expression.
                    Thus the identifier <em>var</em> is bound, and can be used, in <em>expr</em>
                    </div>
                </li>
                <li>
                    <code>(cases <em>expr</em> <em>[pattern expr]...</em>)</code>
                    <div class="description">
                    Perform a pattern match on the result of the first expression.
                    Cases are surrounded by square brackets and each case has one pattern and one expression to be executed if the case matches.
                    Free variables in patterns are bound as expected.
                    </div>
                </li>
                <li>
                    <code>(let <em>pattern</em> <em>expr</em> <em>expr</em>)</code>
                    <div class="description">
                    Introduces a definition for each free variable in a given pattern (that must be exhaustive) that matches the first expression in the second expression.
                    Non-trivial patterns are useful when a type has only one constructor, for example <code>Tuple</code>.
                    </div>
                </li>
                <li>
                    <code>(if <em>expr</em> <em>expr</em> <em>expr</em>)</code>
                    <div class="description">
                    Performs a conditional check. The first expression is expected to reduce to either <code>True</code> or <code>False</code>
                    </div>
                </li>
                <li>
                    <code>(not <em>expr</em>)</code>
                    <div class="description">
                    Negates the booleans <code>True</code> or <code>False</code>
                    </div>
                </li>
                <li>
                    <code>(and <em>expr</em> <em>expr</em>)</code>
                    <div class="description">
                    Computes the conjunction of two booleans
                    </div>
                </li>
                <li>
                    <code>(or <em>expr</em> <em>expr</em>)</code>
                    <div class="description">
                    Computes the disjunction of two booleans
                    </div>
                </li>
                <li>
                    <code>(implies <em>expr</em> <em>expr</em>)</code>
                    <div class="description">
                    Computes the implication between two booleans where the first expression is the antecedent and the second expression is the consequent.
                    </div>
                </li>
                <li>
                    <code>(type <em>var</em> <em>type</em>)</code>
                    <div class="description">
                    Introduce a type alias.
                    <em>var</em> will be bound to <em>type</em> in the rest of the program.
                    </div>
                </li>
            </ul>

            <h3>Patterns</h3>
            <ul>
                <li>
                    <code>var</code>
                    <div class="description">
                    A pattern that will bind to everything.
                    </div>
                </li>
                <li>
                    <code>(<em>K</em> <em>pattern...</em>)</code>
                    <div class="description">
                    A pattern that will only match expressions constructed with the constructor <em>K</em> and whose arguments match each subpattern.
                    </div>
                </li>
            </ul>

            <h3>Properties</h3>
            <ul>
                <li>
                    <code>comm</code>
                    <div class="description">
                    Commutativity: <code>(f x y) = (f y x)</code>
                    </div>
                </li>
                <li>
                    <code>assoc</code>
                    <div class="description">
                    Associativity: <code>(f (f x y) z) = (f x (f y z))</code>
                    </div>
                </li>
                <li>
                    <code>idem</code>
                    <div class="description">
                    Idempotency: <code>f x x = x</code>
                    </div>
                </li>
                <li>
                    <code>sel</code>
                    <div class="description">
                    Selectivity: <code>f x y = x</code> or <code>f x y = y</code>
                    </div>
                </li>
                <li>
                    <code>refl</code>
                    <div class="description">
                    Reflexivity: <code>f x x = True</code>
                    </div>
                </li>
                <li>
                    <code>irefl</code>
                    <div class="description">
                    Irreflexivity: <code>f x x = False</code>
                    </div>
                </li>
                <li>
                    <code>sym</code>
                    <div class="description">
                    Symmetry: If <code>f x y = True</code> then <code>f y x = True</code>
                    </div>
                </li>
                <li>
                    <code>antisym</code>
                    <div class="description">
                    Antisymmetry: If <code>f x y = True</code> and <code>f y x = True</code> then <code>x = y</code>
                    </div>
                </li>
                <li>
                    <code>asym</code>
                    <div class="description">
                    Assymetry: If <code>f x y = True</code> then <code>f y x = False</code>
                    </div>
                </li>
                <li>
                    <code>conn</code>
                    <div class="description">
                    Connectedness: <code>f x y = True</code> or <code>f y x = True</code>
                    </div>
                </li>
                <li>
                    <code>trans</code>
                    <div class="description">
                    Transitivity: If <code>f x y = True</code> and <code>f y z = True</code> then <code>f x z = True</code>
                    </div>
                </li>
            </ul>

            <h3>Types</h3>
            <ul>
                <li>
                    <code><em>var</em></code>
                    <div class="description">
                    A type identifier as defined through <code>type</code>, or a type variable as bound by <code>rec</code> and <code>forall</code>
                    </div>
                </li>
                <li>
                    <code>{<em>constructor...</em>}</code>
                    <div class="description">
                    Defines a tagged union defined by at least one constructor.
                    Additionally, if constructors take arguments, then each argument's type must be present alongside the constructor inside parenthesis.
                    </div>
                </li>
                <li>
                    <code>(rec <em>var</em> <em>type</em>)</code>
                    <div class="description">
                    Defines a recursive type.
                    <em>var</em> will be bound to the recursive type inside <em>type</em>.
                    </div>
                </li>
                <li>
                    <code>(forall <em>var</em> <em>type</em>)</code>
                    <div class="description">
                    Defines a polymorphic type.
                    <em>var</em> is bound in <em>type</em>
                    </div>
                </li>
            </ul>
            </div>
            <div id="selected-description">
            </div>
        <!--}}}--></div>
        <div id="controls">
            <input type="button" value="Check" id="checkCode"></input>
            <select id="example">
                <option value="bv_eq" selected>BitVector equality</option>
                <option value="nat_add3p">Peano Number addition</option>
                <option value="natlist_gcounter">GCounter merge</option>
            </select>
            <input type="checkbox" id="printReduction">
            <label for="printReduction">Print reductions</label>
            <input type="checkbox" id="printDeduction">
            <label for="printDeduction">Print deductions</label>
            <input type="checkbox" id="checkOnInput">
            <label for="checkOnInput">Check on change</label>
        </div>
        <div id="codeAndConsole">
            <div id="codewrapper">
                <pre id="viewer"></pre>
                <textarea id="editor" spellcheck="false"></textarea>
            </div>
            <div id="consoleContainer">
                <pre id="console">Click on 'Check' to start the checking</pre>
            </div>
        </div>
        <div id="status"><br></div>
    </div>
</div>

<main>
    <h1>Conflict-Free Replicated Data-Types (CRDT)</h1>
    <p>
    A state-based Conflict-Free Replicated Data-Type (CRDT) is any datatype that implements a <code>merge</code> function that merges any two instances&mdash;any two replicas&mdash;into one without any conflict or manual conflict resolution.
    We expect the two following properties to hold:
    </p>
    <ol>
        <li>The order of merging any number of replicas should not change the result, and</li>
        <li>merging a replica with itself must not introduce any change to that replica, i.e. the replica remains constant.</li>
    </ol>
    <p>
    When applied to two replicas the first property entails that <code>merge</code> must be <em>commutative</em>.
    When applied to three or more replicas the first property entails that <code>merge</code> must be <em>associative</em>.
    And the second property entails that <code>merge</code> must be <em>idempotent</em>.
    </p>

    <p>
    <strong>How do we guarantee that implementations of <code>merge</code> satisfy these properties?</strong>
    The state of the art is to verify models of these CRDTs manually or automatically by instantiating some framework.
    Other works have developed code synthesizers that generate a <code>merge</code> function with the required properties given the desired semantics.
    Both approaches limit developers.
    Our solution is to develop a type-system that tracks these properties and a compiler that can prove these properties at compile-time.
    </p>

    <h1>Properties</h1>
    <h2>Binary Functions</h2>
    <h2>Binary Relations</h2>

    <h1>Scala DSL</h1>

    <h1>Getting Started</h1>

    <h1>Publications</h1>
    <ol class="publications">
        <li>George Zakhour, Pascal Weisenburger, and Guido Salvaneschi. 2023. Type-Checking CRDT Convergence.
            In <em>Proceedings of the 44th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, PLDI, June 17-21, 2023, Orlando, Florida, United States. <a href="https://doi.org/10.1145/3591276">https://doi.org/10.1145/3591276</a> [<a href="https://programming-group.com/assets/pdf/papers/2023_Type-Checking-CRDT-Convergence.pdf">author version</a>]</li>
    </ol>
</main>

<footer>
Propel is a research language developed at the <a href="https://programming-group.com">Programming Group</a>
&copy; 2023
</footer>

<script type="text/propel" id="bv_eq">
; type definitions
(type bitvec (rec x {(B0 x) (B1 x) BZ}))
(type bool {True False})

; definition of equality over bitvectors
(letrec bv_eq (fun bitvec bitvec bool)
  ; it must be reflexive, transitive, and antisymmetric
  (lambda [refl trans antisym] (x bitvec) (y bitvec)
    (cases (Tuple x y)
        [(Tuple BZ BZ) True]
        [(Tuple (B0 x) (B0 y)) (bv_eq x y)]
        [(Tuple (B1 x) (B1 y)) (bv_eq x y)]
        [_ False]))

Unit)
</script>

<script type="text/propel" id="nat_add3p">
; type definitions
(type nat (rec x {(S x) Z}))

; definition of addition over the natural numbers
(letrec nat_add3p (fun nat nat nat)
  ; it must be commutative and associative
  (lambda [comm assoc] (x nat) (y nat)
    (cases (Tuple x y)
        [(Tuple Z y) y]
        [(Tuple x Z) x]
        [(Tuple (S x) (S y)) (S (S (nat_add3p x y)))]))
Unit)
</script>

<script type="text/propel" id="natlist_gcounter">
; type definitions
(type nat (rec x {(S x) Z}))
(type list (rec x {(Cons nat x) Nil}))

; definition of maximum over the natural numbers
(letrec nat_max (fun nat nat nat)
  ; it must be idempotent, commutative, and associative
  (lambda [idem comm assoc] (x nat) (y nat)
    (cases (Tuple x y)
      [(Tuple Z y) y]
      [(Tuple x Z) x]
      [(Tuple (S x) (S y)) (S (nat_max x y))]))

; definition of the merge function of a GCounter
(letrec natlist_gcounter (fun list list list)
  ; it must be idempotent, commutative, and associative
  (lambda [idem comm assoc] (x list) (y list)
    (cases (Tuple x y)
      [(Tuple Nil y) y]
      [(Tuple x Nil) x]
      [(Tuple (Cons x xs) (Cons y ys))
       (Cons (nat_max x y) (natlist_gcounter xs ys))]))

Unit))
</script>

<script src="editor.js"></script>
</body>
</html>
